#!/bin/bash
# Pass Insert Utility for API Keys
# Manages pass initialization and provides easy API key storage with export generation

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script variables
GPG_KEY_ID=""
GENERATE_PASSWORD=false
PASSWORD_LENGTH=32

# Helper functions
print_header() {
    echo -e "${BLUE}🔐 Pass Insert Utility for API Keys${NC}"
    echo -e "${BLUE}=====================================${NC}"
}

print_error() {
    echo -e "${RED}❌ Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo -e "${CYAN}ℹ️  $1${NC}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check pass installation
check_pass_installed() {
    if ! command_exists pass; then
        print_error "pass is not installed. Please install it first."
        print_info "Run: sudo pacman -S pass"
        exit 1
    fi
}

# Check pass initialization
check_pass_initialized() {
    if [[ ! -f "$HOME/.password-store/.gpg-id" ]]; then
        return 1
    fi
    return 0
}

# Get existing GPG keys for fzf selection
get_gpg_keys() {
    gpg --list-secret-keys --with-colons | grep "^uid:" | sed 's/^uid:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\(.*\):/\1/'
}

# Get key ID from selected email
get_key_id_from_email() {
    local email="$1"
    gpg --list-secret-keys --with-colons "$email" | grep "^sec:" | awk -F: '{print $5}'
}

# Create new GPG key
create_gpg_key() {
    print_info "Creating new GPG key..."
    print_warning "This will require interactive input for key generation."

    gpg --gen-key

    # Get the newly created key ID (most recent secret key)
    GPG_KEY_ID=$(gpg --list-secret-keys --with-colons | grep "^sec:" | tail -1 | awk -F: '{print $5}')

    if [[ -z "$GPG_KEY_ID" ]]; then
        print_error "Failed to get key ID after creation"
        exit 1
    fi

    print_success "Created GPG key: $GPG_KEY_ID"
}

# Initialize pass with GPG key
initialize_pass() {
    print_info "Initializing pass with GPG key: $GPG_KEY_ID"
    pass init "$GPG_KEY_ID"
    print_success "Pass initialized successfully"
}

# Handle pass initialization
handle_initialization() {
    print_warning "Pass is not initialized."

    while true; do
        echo -e "${PURPLE}Do you want to use an existing GPG key or create a new one?${NC}"
        echo -n "[existing/new/cancel]? "
        read -r choice

        case "${choice,,}" in
            "existing"|"e")
                # Check if fzf is available
                if ! command_exists fzf; then
                    print_error "fzf is required for key selection. Install with: sudo pacman -S fzf"
                    exit 1
                fi

                # Get available keys
                local keys
                keys=$(get_gpg_keys)

                if [[ -z "$keys" ]]; then
                    print_error "No GPG secret keys found. Please create one first."
                    exit 1
                fi

                # Select key with fzf
                local selected_email
                selected_email=$(echo "$keys" | fzf --prompt="Select GPG key: " --height=10)

                if [[ -z "$selected_email" ]]; then
                    print_warning "No key selected. Exiting."
                    exit 0
                fi

                GPG_KEY_ID=$(get_key_id_from_email "$selected_email")

                if [[ -z "$GPG_KEY_ID" ]]; then
                    print_error "Failed to get key ID for selected email"
                    exit 1
                fi

                print_success "Selected GPG key: $selected_email ($GPG_KEY_ID)"
                break
                ;;
            "new"|"n")
                create_gpg_key
                break
                ;;
            "cancel"|"c")
                print_info "Operation cancelled."
                exit 0
                ;;
            *)
                print_error "Invalid choice. Please enter 'existing', 'new', or 'cancel'."
                ;;
        esac
    done

    initialize_pass
}

# Transform name to pass format (lowercase, underscores)
transform_name() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | tr ' ' '_'
}

# Transform name to export variable format (uppercase, underscores)
transform_to_export_var() {
    echo "$1" | tr '[:lower:]' '[:upper:]' | tr ' ' '_'
}

# Generate secure password
generate_password() {
    if command_exists pwgen; then
        pwgen -s "$PASSWORD_LENGTH" 1
    elif command_exists openssl; then
        openssl rand -base64 "$PASSWORD_LENGTH" | tr -d "=+/" | cut -c1-"$PASSWORD_LENGTH"
    else
        print_error "No password generator found. Install pwgen or openssl."
        exit 1
    fi
}

# Insert password into pass
insert_password() {
    local pass_path="$1"
    local password="$2"

    echo "$password" | pass insert --echo "$pass_path"
}

# Append export to load-api-keys.sh
append_export() {
    local export_var="$1"
    local pass_path="$2"
    local load_file="$HOME/load-api-keys.sh"

    # Create file if it doesn't exist
    if [[ ! -f "$load_file" ]]; then
        echo "#!/bin/bash" > "$load_file"
        echo "" >> "$load_file"
        echo "# API Keys loaded from pass" >> "$load_file"
        chmod +x "$load_file"
    fi

    # Check if export already exists
    if grep -q "export $export_var=" "$load_file"; then
        print_warning "Export for $export_var already exists in $load_file"
        return
    fi

    # Append export
    echo "export $export_var=\$(pass $pass_path)" >> "$load_file"
    print_success "Added export to $load_file"
}

# Main insert utility
do_insert() {
    print_info "Enter API key details:"

    # Get category
    while true; do
        echo -n "Category (e.g., ai): "
        read -r category
        if [[ -n "$category" ]]; then
            break
        fi
        print_error "Category cannot be empty"
    done

    # Get name
    while true; do
        echo -n "Name (e.g., openrouter api key): "
        read -r name
        if [[ -n "$name" ]]; then
            break
        fi
        print_error "Name cannot be empty"
    done

    # Transform name
    local transformed_name
    transformed_name=$(transform_name "$name")

    # Create pass path
    local pass_path="$category/$transformed_name"

    # Create export variable name
    local export_var
    export_var=$(transform_to_export_var "$name")

    print_info "Will create: $pass_path"
    print_info "Export var: $export_var"

    # Get password
    local password
    if [[ "$GENERATE_PASSWORD" == true ]]; then
        password=$(generate_password)
        print_info "Generated password: $password"
    else
        echo -n "Enter password (or press Enter to generate): "
        read -r password
        if [[ -z "$password" ]]; then
            password=$(generate_password)
            print_info "Generated password: $password"
        fi
    fi

    # Insert into pass
    insert_password "$pass_path" "$password"

    # Append export
    append_export "$export_var" "$pass_path"

    print_success "API key stored successfully!"
    print_info "Use: source ~/load-api-keys.sh to load the key"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -g|--generate)
            GENERATE_PASSWORD=true
            shift
            ;;
        -l|--length)
            PASSWORD_LENGTH="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -g, --generate    Generate a secure password"
            echo "  -l, --length NUM  Password length (default: 32)"
            echo "  -h, --help        Show this help"
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            echo "Use -h for help"
            exit 1
            ;;
    esac
done

# Main execution
main() {
    print_header

    # Pre-checks
    check_pass_installed

    if ! check_pass_initialized; then
        handle_initialization
    fi

    # Do the insert
    do_insert
}

# Run main
main "$@"